<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Chunked Upload Service&#10;&#10;This project implements a resumable file upload server in Java (Spring Boot) without using a database. It stores file chunks and maintains a simple header file to track uploaded chunks and uses a dedicated directory structure for in-progress and completed uploads.&#10;&#10;## Features&#10;- Chunked upload with resume support&#10;- File header to track uploaded chunks&#10;- Resumable uploads without database&#10;- Simple cache directory&#10;- JUnit tests&#10;- Original filename is required and preserved for completed uploads&#10;- Modular architecture: controller, service, session manager, bitset manager&#10;&#10;## Directory Structure&#10;- `uploads/in-progress/`: Temporary storage for in-progress uploads (chunk data and header)&#10;- `uploads/complete/`: Final assembled files, named as `&lt;uploadId&gt;_&lt;originalFilename&gt;`&#10;&#10;## API Endpoints&#10;&#10;### 1. `POST /api/upload/init`&#10;**Request Body:**&#10;```json&#10;{&#10;  &quot;totalChunks&quot;: 2,&#10;  &quot;chunkSize&quot;: 10,&#10;  &quot;fileSize&quot;: 20,&#10;  &quot;filename&quot;: &quot;myfile.txt&quot;&#10;}&#10;```&#10;**Response:**&#10;```json&#10;{&#10;  &quot;uploadId&quot;: &quot;...&quot;,&#10;  &quot;totalChunks&quot;: 2,&#10;  &quot;chunkSize&quot;: 10,&#10;  &quot;fileSize&quot;: 20,&#10;  &quot;filename&quot;: &quot;myfile.txt&quot;&#10;}&#10;```&#10;&#10;### 2. `POST /api/upload/chunk`&#10;**Form Data:**&#10;- `uploadId`, `chunkNumber`, `totalChunks`, `chunkSize`, `fileSize`, `chunkChecksum`, `file` (chunk data)&#10;- On last chunk, server assembles the file as `&lt;uploadId&gt;_&lt;filename&gt;` in `uploads/complete/`&#10;&#10;### 3. `GET /api/upload/{uploadId}/status`&#10;Returns upload status and chunk progress.&#10;&#10;### 4. `DELETE /api/upload/{uploadId}`&#10;Aborts and cleans up an in-progress upload.&#10;&#10;## Sequence Diagram&#10;&#10;```mermaid&#10;sequenceDiagram&#10;    participant Client&#10;    participant Controller&#10;    participant Service&#10;    participant SessionManager&#10;    participant BitsetManager&#10;    participant FileSystem&#10;    Client-&gt;&gt;Controller: POST /api/upload/init (filename, size, ...)&#10;    Controller-&gt;&gt;Service: create header, store filename&#10;    Controller-&gt;&gt;SessionManager: start session&#10;    Controller--&gt;&gt;Client: uploadId&#10;    loop For each chunk&#10;        Client-&gt;&gt;Controller: POST /api/upload/chunk (chunk, uploadId, ...)&#10;        Controller-&gt;&gt;Service: write chunk&#10;        Controller-&gt;&gt;BitsetManager: mark chunk, check complete&#10;        alt Last chunk&#10;            Controller-&gt;&gt;Service: assemble file as &lt;uploadId&gt;_&lt;filename&gt;&#10;            Controller-&gt;&gt;SessionManager: end session&#10;            Controller--&gt;&gt;Client: status=completed, finalPath&#10;        else Not last chunk&#10;            Controller--&gt;&gt;Client: status=ok&#10;        end&#10;    end&#10;```&#10;&#10;## Class Diagram&#10;&#10;```mermaid&#10;classDiagram&#10;    class ChunkedUploadController {&#10;        +initUpload()&#10;        +uploadChunk()&#10;        +getStatus()&#10;        +abort()&#10;        -uploadService&#10;        -sessionManager&#10;        -bitsetManager&#10;    }&#10;    class ChunkedUploadService {&#10;        +storeFilename()&#10;        +createOrValidateHeader()&#10;        +writeChunk()&#10;        +assembleFile()&#10;        +getPartPath()&#10;        +getFinalPath()&#10;    }&#10;    class SessionManager {&#10;        +startSession()&#10;        +endSession()&#10;        +getStatus()&#10;    }&#10;    class BitsetManager {&#10;        +markChunkAndCheckComplete()&#10;        +getBitset()&#10;    }&#10;    ChunkedUploadController --&gt; ChunkedUploadService&#10;    ChunkedUploadController --&gt; SessionManager&#10;    ChunkedUploadController --&gt; BitsetManager&#10;```&#10;&#10;## Implementation Notes&#10;- The original filename is required in the `/init` API and is used for the final assembled file.&#10;- All chunk and session management is in-memory and file-based (no database).&#10;- The service is robust for resumable and concurrent uploads.&#10;- Controller, service, and helper classes are all ≤100 lines, methods ≤20 lines for maintainability.&#10;&#10;## Build &amp; Run&#10;```bash&#10;./gradlew build&#10;./gradlew run&#10;```&#10;" />
              <option name="updatedContent" value="# Chunked Upload Service&#10;&#10;This project implements a resumable file upload server in Java (Spring Boot) with a modular architecture. It stores file chunks and maintains a simple header file to track uploaded chunks, using a dedicated directory structure for in-progress and completed uploads.&#10;&#10;## Features&#10;- Chunked upload with resume support&#10;- File header to track uploaded chunks&#10;- Resumable uploads without database&#10;- Simple cache directory&#10;- JUnit tests&#10;- Original filename is required and preserved for completed uploads&#10;- Modular architecture: controller, service, session manager, bitset manager&#10;&#10;## Directory Structure&#10;- `uploads/in-progress/`: Temporary storage for in-progress uploads (chunk data and header)&#10;- `uploads/complete/`: Final assembled files, named as `&lt;uploadId&gt;_&lt;originalFilename&gt;`&#10;&#10;## API Endpoints&#10;&#10;### 1. `POST /api/upload/init`&#10;**Request Body:**&#10;```json&#10;{&#10;  &quot;totalChunks&quot;: 2,&#10;  &quot;chunkSize&quot;: 10,&#10;  &quot;fileSize&quot;: 20,&#10;  &quot;filename&quot;: &quot;myfile.txt&quot;&#10;}&#10;```&#10;**Response:**&#10;```json&#10;{&#10;  &quot;uploadId&quot;: &quot;...&quot;,&#10;  &quot;totalChunks&quot;: 2,&#10;  &quot;chunkSize&quot;: 10,&#10;  &quot;fileSize&quot;: 20,&#10;  &quot;filename&quot;: &quot;myfile.txt&quot;&#10;}&#10;```&#10;&#10;### 2. `POST /api/upload/chunk`&#10;**Form Data:**&#10;- `uploadId`, `chunkNumber`, `totalChunks`, `chunkSize`, `fileSize`, `chunkChecksum`, `file` (chunk data)&#10;- On last chunk, server assembles the file as `&lt;uploadId&gt;_&lt;filename&gt;` in `uploads/complete/`&#10;- Response always includes `nextChunk` (null if completed)&#10;&#10;### 3. `GET /api/upload/{uploadId}/status`&#10;Returns upload status and chunk progress.&#10;&#10;### 4. `DELETE /api/upload/{uploadId}`&#10;Aborts and cleans up an in-progress upload.&#10;&#10;## Sequence Diagram&#10;&#10;```mermaid&#10;sequenceDiagram&#10;    participant Client&#10;    participant Controller&#10;    participant Service&#10;    participant SessionManager&#10;    participant BitsetManager&#10;    participant FileSystem&#10;    Client-&gt;&gt;Controller: POST /api/upload/init (filename, size, ...)&#10;    Controller-&gt;&gt;Service: create header, store filename&#10;    Controller-&gt;&gt;SessionManager: start session&#10;    Controller--&gt;&gt;Client: uploadId&#10;    loop For each chunk&#10;        Client-&gt;&gt;Controller: POST /api/upload/chunk (chunk, uploadId, ...)&#10;        Controller-&gt;&gt;Service: write chunk&#10;        Controller-&gt;&gt;BitsetManager: mark chunk, check complete&#10;        alt Last chunk&#10;            Controller-&gt;&gt;Service: assemble file as &lt;uploadId&gt;_&lt;filename&gt;&#10;            Controller-&gt;&gt;SessionManager: end session&#10;            Controller--&gt;&gt;Client: status=completed, finalPath, nextChunk=null&#10;        else Not last chunk&#10;            Controller--&gt;&gt;Client: status=ok, nextChunk&#10;        end&#10;    end&#10;```&#10;&#10;## Class Diagram&#10;&#10;```mermaid&#10;classDiagram&#10;    class ChunkedUploadController {&#10;        +initUpload()&#10;        +uploadChunk()&#10;        +getStatus()&#10;        +abort()&#10;        -uploadService&#10;        -sessionManager&#10;        -bitsetManager&#10;    }&#10;    class ChunkedUploadService {&#10;        +storeFilename()&#10;        +createOrValidateHeader()&#10;        +writeChunk()&#10;        +assembleFile()&#10;        +getPartPath()&#10;        +getFinalPath()&#10;    }&#10;    class SessionManager {&#10;        +startSession()&#10;        +endSession()&#10;        +getStatus()&#10;    }&#10;    class BitsetManager {&#10;        +markChunkAndCheckComplete()&#10;        +getBitset()&#10;    }&#10;    ChunkedUploadController --&gt; ChunkedUploadService&#10;    ChunkedUploadController --&gt; SessionManager&#10;    ChunkedUploadController --&gt; BitsetManager&#10;```&#10;&#10;## Implementation Notes&#10;- The original filename is required in the `/init` API and is used for the final assembled file.&#10;- All chunk and session management is in-memory and file-based (no database).&#10;- The service is robust for resumable and concurrent uploads.&#10;- Controller, service, and helper classes are all ≤100 lines, methods ≤20 lines for maintainability.&#10;&#10;## Build &amp; Run&#10;```bash&#10;./gradlew build&#10;./gradlew run&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/BitsetManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/BitsetManager.java" />
              <option name="updatedContent" value="package vn.com.fecredit.chunkedupload;&#10;&#10;import org.springframework.stereotype.Component;&#10;import java.io.IOException;&#10;import java.nio.file.Path;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;@Component&#10;public class BitsetManager {&#10;    private final ConcurrentHashMap&lt;String, byte[]&gt; bitsets = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    public boolean markChunkAndCheckComplete(Path partPath, int chunkNumber, int totalChunks) throws IOException {&#10;        byte[] bitset = bitsets.computeIfAbsent(partPath.toString(), k -&gt; new byte[(totalChunks + 7) / 8]);&#10;        int idx = chunkNumber - 1;&#10;        bitset[idx / 8] |= (1 &lt;&lt; (idx % 8));&#10;        for (int i = 0; i &lt; totalChunks; i++) {&#10;            if ((bitset[i / 8] &amp; (1 &lt;&lt; (i % 8))) == 0) return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    public byte[] getBitset(Path partPath, int totalChunks) {&#10;        return bitsets.getOrDefault(partPath.toString(), new byte[(totalChunks + 7) / 8]);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/ChunkedUploadController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/ChunkedUploadController.java" />
              <option name="originalContent" value="package vn.com.fecredit.chunkedupload;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.util.StringUtils;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Path;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/upload&quot;)&#10;public class ChunkedUploadController {&#10;    @Autowired&#10;    private ChunkedUploadService uploadService;&#10;    @Autowired&#10;    private SessionManager sessionManager;&#10;    @Autowired&#10;    private BitsetManager bitsetManager;&#10;&#10;    /**&#10;     * Initialize an upload session.&#10;     * @param req The initialization request containing upload parameters.&#10;     * @return The initialization response containing uploadId and other parameters.&#10;     * @throws IOException If there is a file access error.&#10;     */&#10;    @PostMapping(&quot;/init&quot;)&#10;    public InitResponse initUpload(@RequestBody InitRequest req) throws IOException {&#10;        validateInitRequest(req);&#10;        String uploadId = getOrCreateUploadId(req.uploadId);&#10;        Path partPath = uploadService.getPartPath(uploadId);&#10;        uploadService.storeFilename(uploadId, req.filename);&#10;        uploadService.createOrValidateHeader(partPath, req.totalChunks, req.chunkSize, req.fileSize);&#10;        sessionManager.startSession(uploadId, req.fileSize);&#10;        return new InitResponse(uploadId, req.totalChunks, req.chunkSize, req.fileSize, req.filename);&#10;    }&#10;&#10;    /**&#10;     * Upload a chunk of the file.&#10;     * @param uploadId The upload session ID.&#10;     * @param chunkNumber The chunk number being uploaded.&#10;     * @param totalChunks The total number of chunks.&#10;     * @param chunkSize The size of each chunk.&#10;     * @param fileSize The total size of the file.&#10;     * @param chunkChecksum The checksum of the chunk.&#10;     * @param fileChecksum The checksum of the entire file (optional).&#10;     * @param file The MultipartFile object containing the chunk data.&#10;     * @return A response entity containing the status and nextChunk information.&#10;     * @throws Exception If there is an error processing the upload.&#10;     */&#10;    @PostMapping(&quot;/chunk&quot;)&#10;    public ResponseEntity&lt;?&gt; uploadChunk(@RequestParam String uploadId, @RequestParam int chunkNumber,&#10;                                         @RequestParam int totalChunks, @RequestParam int chunkSize,&#10;                                         @RequestParam long fileSize, @RequestParam String chunkChecksum,&#10;                                         @RequestParam(required = false) String fileChecksum,&#10;                                         @RequestParam(&quot;file&quot;) MultipartFile file) throws Exception {&#10;        Path partPath = uploadService.getPartPath(uploadId);&#10;        uploadService.writeChunk(partPath, chunkNumber, chunkSize, file.getBytes());&#10;        boolean isLastChunk = bitsetManager.markChunkAndCheckComplete(partPath, chunkNumber, totalChunks);&#10;        if (isLastChunk) {&#10;            Path finalPath = uploadService.getFinalPath(uploadId);&#10;            uploadService.assembleFile(partPath, finalPath, chunkSize, fileSize, bitsetManager.getBitset(partPath, totalChunks));&#10;            uploadService.removeFilename(uploadId);&#10;            sessionManager.endSession(uploadId);&#10;            Map&lt;String, Object&gt; result = new java.util.HashMap&lt;&gt;();&#10;            result.put(&quot;status&quot;, &quot;completed&quot;);&#10;            result.put(&quot;nextChunk&quot;, null);&#10;            result.put(&quot;finalPath&quot;, finalPath.toString());&#10;            return ResponseEntity.ok(result);&#10;        }&#10;        // Always return nextChunk for non-final chunk&#10;        int nextChunk = findNextMissingChunk(bitsetManager.getBitset(partPath, totalChunks), totalChunks);&#10;        Map&lt;String, Object&gt; result = new java.util.HashMap&lt;&gt;();&#10;        result.put(&quot;status&quot;, &quot;ok&quot;);&#10;        result.put(&quot;nextChunk&quot;, nextChunk);&#10;        return ResponseEntity.ok(result);&#10;    }&#10;&#10;    /**&#10;     * Get the status of an upload session.&#10;     * @param uploadId The upload session ID.&#10;     * @return Status information for the upload session.&#10;     * @throws IOException If there is a file access error.&#10;     */&#10;    @GetMapping(&quot;/{uploadId}/status&quot;)&#10;    public ResponseEntity&lt;?&gt; getStatus(@PathVariable String uploadId) throws IOException {&#10;        return ResponseEntity.ok(sessionManager.getStatus(uploadId));&#10;    }&#10;&#10;    /**&#10;     * Abort and clean up an in-progress upload session.&#10;     * @param uploadId The upload session ID.&#10;     * @return HTTP 204 No Content if successful.&#10;     * @throws IOException If there is a file access error.&#10;     */&#10;    @DeleteMapping(&quot;/{uploadId}&quot;)&#10;    public ResponseEntity&lt;?&gt; abort(@PathVariable String uploadId) throws IOException {&#10;        uploadService.removeFilename(uploadId);&#10;        sessionManager.endSession(uploadId);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    /**&#10;     * Validate the init request for required fields and values.&#10;     * @param req The init request object.&#10;     * @throws IllegalArgumentException If any required field is missing or invalid.&#10;     */&#10;    private void validateInitRequest(InitRequest req) {&#10;        if (req.totalChunks &lt;= 0 || req.chunkSize &lt;= 0 || req.fileSize &lt;= 0 || !StringUtils.hasText(req.filename)) {&#10;            throw new IllegalArgumentException(&quot;totalChunks, chunkSize, fileSize, filename must be &gt; 0 and filename must be provided&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get or create a new upload session ID.&#10;     * @param uploadId The provided uploadId, or null/empty for new.&#10;     * @return The upload session ID.&#10;     */&#10;    private String getOrCreateUploadId(String uploadId) {&#10;        return StringUtils.hasText(uploadId) ? uploadId : java.util.UUID.randomUUID().toString();&#10;    }&#10;&#10;    /**&#10;     * Find the next missing chunk number in the bitset.&#10;     * @param bitset The bitset representing received chunks.&#10;     * @param totalChunks The total number of chunks.&#10;     * @return The next missing chunk number, or -1 if all are present.&#10;     */&#10;    private int findNextMissingChunk(byte[] bitset, int totalChunks) {&#10;        for (int i = 0; i &lt; totalChunks; i++) {&#10;            if ((bitset[i / 8] &amp; (1 &lt;&lt; (i % 8))) == 0) return i + 1;&#10;        }&#10;        return -1;&#10;    }&#10;&#10;    public static class InitRequest {&#10;        public String uploadId;&#10;        public int totalChunks;&#10;        public int chunkSize;&#10;        public long fileSize;&#10;        public String filename; // &lt;-- add filename&#10;    }&#10;    public static class InitResponse {&#10;        public String uploadId;&#10;        public int totalChunks;&#10;        public int chunkSize;&#10;        public long fileSize;&#10;        public String filename;&#10;        public InitResponse(String uploadId, int totalChunks, int chunkSize, long fileSize, String filename) {&#10;            this.uploadId = uploadId;&#10;            this.totalChunks = totalChunks;&#10;            this.chunkSize = chunkSize;&#10;            this.fileSize = fileSize;&#10;            this.filename = filename;&#10;        }&#10;    }&#10;    public static class NextResponse { public Integer nextChunk; public NextResponse(Integer next) { this.nextChunk = next; } }&#10;    public static class StatusResponse { public String uploadId; public int totalChunks; public int chunkSize; public long fileSize; public int receivedCount; public boolean completed; public Integer nextMissing; public List&lt;Range&gt; receivedRanges; public List&lt;Range&gt; missingRanges; public List&lt;Integer&gt; reserved; public Long sessionTtlSeconds; }&#10;    public static class Range { public int start; public int end; public Range(int s, int e) { this.start = s; this.end = e; } }&#10;}" />
              <option name="updatedContent" value="package vn.com.fecredit.chunkedupload;&#10;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.util.StringUtils;&#10;import org.springframework.web.bind.annotation.*;&#10;import org.springframework.web.multipart.MultipartFile;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Path;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/upload&quot;)&#10;public class ChunkedUploadController {&#10;    @Autowired&#10;    private ChunkedUploadService uploadService;&#10;    @Autowired&#10;    private SessionManager sessionManager;&#10;    @Autowired&#10;    private BitsetManager bitsetManager;&#10;&#10;    /**&#10;     * Initialize an upload session.&#10;     * @param req The initialization request containing upload parameters.&#10;     * @return The initialization response containing uploadId and other parameters.&#10;     * @throws IOException If there is a file access error.&#10;     */&#10;    @PostMapping(&quot;/init&quot;)&#10;    public InitResponse initUpload(@RequestBody InitRequest req) throws IOException {&#10;        validateInitRequest(req);&#10;        String uploadId = getOrCreateUploadId(req.uploadId);&#10;        Path partPath = uploadService.getPartPath(uploadId);&#10;        uploadService.storeFilename(uploadId, req.filename);&#10;        uploadService.createOrValidateHeader(partPath, req.totalChunks, req.chunkSize, req.fileSize);&#10;        sessionManager.startSession(uploadId, req.fileSize);&#10;        return new InitResponse(uploadId, req.totalChunks, req.chunkSize, req.fileSize, req.filename);&#10;    }&#10;&#10;    /**&#10;     * Upload a chunk of the file.&#10;     * @param uploadId The upload session ID.&#10;     * @param chunkNumber The chunk number being uploaded.&#10;     * @param totalChunks The total number of chunks.&#10;     * @param chunkSize The size of each chunk.&#10;     * @param fileSize The total size of the file.&#10;     * @param chunkChecksum The checksum of the chunk.&#10;     * @param fileChecksum The checksum of the entire file (optional).&#10;     * @param file The MultipartFile object containing the chunk data.&#10;     * @return A response entity containing the status and nextChunk information.&#10;     * @throws Exception If there is an error processing the upload.&#10;     */&#10;    @PostMapping(&quot;/chunk&quot;)&#10;    public ResponseEntity&lt;?&gt; uploadChunk(@RequestParam String uploadId, @RequestParam int chunkNumber,&#10;                                         @RequestParam int totalChunks, @RequestParam int chunkSize,&#10;                                         @RequestParam long fileSize, @RequestParam String chunkChecksum,&#10;                                         @RequestParam(required = false) String fileChecksum,&#10;                                         @RequestParam(&quot;file&quot;) MultipartFile file) throws Exception {&#10;        Path partPath = uploadService.getPartPath(uploadId);&#10;        uploadService.writeChunk(partPath, chunkNumber, chunkSize, file.getBytes());&#10;        boolean isLastChunk = bitsetManager.markChunkAndCheckComplete(partPath, chunkNumber, totalChunks);&#10;        if (isLastChunk) {&#10;            Path finalPath = uploadService.getFinalPath(uploadId);&#10;            uploadService.assembleFile(partPath, finalPath, chunkSize, fileSize, bitsetManager.getBitset(partPath, totalChunks));&#10;            uploadService.removeFilename(uploadId);&#10;            sessionManager.endSession(uploadId);&#10;            Map&lt;String, Object&gt; result = new java.util.HashMap&lt;&gt;();&#10;            result.put(&quot;status&quot;, &quot;completed&quot;);&#10;            result.put(&quot;nextChunk&quot;, null);&#10;            result.put(&quot;finalPath&quot;, finalPath.toString());&#10;            return ResponseEntity.ok(result);&#10;        }&#10;        // Always return nextChunk for non-final chunk&#10;        int nextChunk = findNextMissingChunk(bitsetManager.getBitset(partPath, totalChunks), totalChunks);&#10;        Map&lt;String, Object&gt; result = new java.util.HashMap&lt;&gt;();&#10;        result.put(&quot;status&quot;, &quot;ok&quot;);&#10;        result.put(&quot;nextChunk&quot;, nextChunk);&#10;        return ResponseEntity.ok(result);&#10;    }&#10;&#10;    /**&#10;     * Get the status of an upload session.&#10;     * @param uploadId The upload session ID.&#10;     * @return Status information for the upload session.&#10;     * @throws IOException If there is a file access error.&#10;     */&#10;    @GetMapping(&quot;/{uploadId}/status&quot;)&#10;    public ResponseEntity&lt;?&gt; getStatus(@PathVariable String uploadId) throws IOException {&#10;        return ResponseEntity.ok(sessionManager.getStatus(uploadId));&#10;    }&#10;&#10;    /**&#10;     * Abort and clean up an in-progress upload session.&#10;     * @param uploadId The upload session ID.&#10;     * @return HTTP 204 No Content if successful.&#10;     * @throws IOException If there is a file access error.&#10;     */&#10;    @DeleteMapping(&quot;/{uploadId}&quot;)&#10;    public ResponseEntity&lt;?&gt; abort(@PathVariable String uploadId) throws IOException {&#10;        uploadService.removeFilename(uploadId);&#10;        sessionManager.endSession(uploadId);&#10;        return ResponseEntity.noContent().build();&#10;    }&#10;&#10;    /**&#10;     * Validate the init request for required fields and values.&#10;     * @param req The init request object.&#10;     * @throws IllegalArgumentException If any required field is missing or invalid.&#10;     */&#10;    private void validateInitRequest(InitRequest req) {&#10;        if (req.totalChunks &lt;= 0 || req.chunkSize &lt;= 0 || req.fileSize &lt;= 0 || !StringUtils.hasText(req.filename)) {&#10;            throw new IllegalArgumentException(&quot;totalChunks, chunkSize, fileSize, filename must be &gt; 0 and filename must be provided&quot;);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get or create a new upload session ID.&#10;     * @param uploadId The provided uploadId, or null/empty for new.&#10;     * @return The upload session ID.&#10;     */&#10;    private String getOrCreateUploadId(String uploadId) {&#10;        return StringUtils.hasText(uploadId) ? uploadId : java.util.UUID.randomUUID().toString();&#10;    }&#10;&#10;    /**&#10;     * Find the next missing chunk number in the bitset.&#10;     * @param bitset The bitset representing received chunks.&#10;     * @param totalChunks The total number of chunks.&#10;     * @return The next missing chunk number, or -1 if all are present.&#10;     */&#10;    private int findNextMissingChunk(byte[] bitset, int totalChunks) {&#10;        for (int i = 0; i &lt; totalChunks; i++) {&#10;            if ((bitset[i / 8] &amp; (1 &lt;&lt; (i % 8))) == 0) return i + 1;&#10;        }&#10;        return -1;&#10;    }&#10;&#10;    public static class InitRequest {&#10;        public String uploadId;&#10;        public int totalChunks;&#10;        public int chunkSize;&#10;        public long fileSize;&#10;        public String filename; // &lt;-- add filename&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/ChunkedUploadService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/ChunkedUploadService.java" />
              <option name="originalContent" value="package vn.com.fecredit.chunkedupload;&#10;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.util.StringUtils;&#10;import org.springframework.web.multipart.MultipartFile;&#10;&#10;import java.io.IOException;&#10;import java.nio.channels.FileChannel;&#10;import java.nio.file.*;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;@Service&#10;public class ChunkedUploadService {&#10;    private final Path inProgressDir = Paths.get(&quot;uploads/in-progress&quot;);&#10;    private final Path completeDir = Paths.get(&quot;uploads/complete&quot;);&#10;    private final ConcurrentHashMap&lt;String, String&gt; uploadFilenames = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;String, ReentrantLock&gt; locks = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    public ChunkedUploadService() throws IOException {&#10;        Files.createDirectories(inProgressDir);&#10;        Files.createDirectories(completeDir);&#10;    }&#10;&#10;    public void storeFilename(String uploadId, String filename) {&#10;        uploadFilenames.put(uploadId, filename);&#10;    }&#10;&#10;    public String getFilename(String uploadId) {&#10;        return uploadFilenames.get(uploadId);&#10;    }&#10;&#10;    public void removeFilename(String uploadId) {&#10;        uploadFilenames.remove(uploadId);&#10;    }&#10;&#10;    public Path getPartPath(String uploadId) {&#10;        return inProgressDir.resolve(uploadId + &quot;.part&quot;);&#10;    }&#10;&#10;    public Path getFinalPath(String uploadId) {&#10;        String filename = getFilename(uploadId);&#10;        return completeDir.resolve(uploadId + (StringUtils.hasText(filename) ? (&quot;_&quot; + filename) : &quot;&quot;));&#10;    }&#10;&#10;    public ReentrantLock getLock(String uploadId) {&#10;        return locks.computeIfAbsent(uploadId, k -&gt; new ReentrantLock());&#10;    }&#10;&#10;    public void removeLock(String uploadId) {&#10;        locks.remove(uploadId);&#10;    }&#10;&#10;    public void createOrValidateHeader(Path partPath, int totalChunks, int chunkSize, long fileSize) throws IOException {&#10;        int bitsetBytes = (totalChunks + 7) / 8;&#10;        int headerSize = 4 + 4 + 4 + 8 + bitsetBytes;&#10;        try (var raf = new java.io.RandomAccessFile(partPath.toFile(), &quot;rw&quot;);&#10;             var ch = raf.getChannel()) {&#10;            if (ch.size() == 0) {&#10;                var header = java.nio.ByteBuffer.allocate(headerSize).order(java.nio.ByteOrder.BIG_ENDIAN);&#10;                header.putInt(0xCAFECAFE);&#10;                header.putInt(totalChunks);&#10;                header.putInt(chunkSize);&#10;                header.putLong(fileSize);&#10;                header.put(new byte[bitsetBytes]);&#10;                header.flip();&#10;                ch.write(header, 0);&#10;                raf.setLength(headerSize + (long) totalChunks * chunkSize);&#10;            } else {&#10;                var h = readHeader(ch);&#10;                if (h.totalChunks != totalChunks || h.chunkSize != chunkSize || h.fileSize != fileSize) {&#10;                    throw new IllegalStateException(&quot;Existing upload file has different parameters&quot;);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public Header readHeader(FileChannel ch) throws IOException {&#10;        var fixed = java.nio.ByteBuffer.allocate(20).order(java.nio.ByteOrder.BIG_ENDIAN);&#10;        ch.read(fixed, 0);&#10;        fixed.flip();&#10;        int magic = fixed.getInt();&#10;        if (magic != 0xCAFECAFE) throw new IOException(&quot;Bad magic in upload file header&quot;);&#10;        int totalChunks = fixed.getInt();&#10;        int chunkSize = fixed.getInt();&#10;        long fileSize = fixed.getLong();&#10;        int bitsetBytes = (totalChunks + 7) / 8;&#10;        var bits = java.nio.ByteBuffer.allocate(bitsetBytes);&#10;        ch.read(bits, 20);&#10;        return new Header(totalChunks, chunkSize, fileSize, bits.array());&#10;    }&#10;&#10;    public static class Header {&#10;        public int totalChunks;&#10;        public int chunkSize;&#10;        public long fileSize;&#10;        public byte[] bitset;&#10;        public Header(int t, int c, long f, byte[] b) {&#10;            this.totalChunks = t;&#10;            this.chunkSize = c;&#10;            this.fileSize = f;&#10;            this.bitset = b;&#10;        }&#10;    }&#10;&#10;    public void writeChunk(Path partPath, int chunkNumber, int chunkSize, byte[] data) throws IOException {&#10;        int idx = chunkNumber - 1;&#10;        try (var raf = new java.io.RandomAccessFile(partPath.toFile(), &quot;rw&quot;);&#10;             var ch = raf.getChannel()) {&#10;            var h = readHeader(ch);&#10;            long headerSize = 4 + 4 + 4 + 8 + h.bitset.length;&#10;            long offset = headerSize + (long) idx * chunkSize;&#10;            ch.position(offset);&#10;            ch.write(java.nio.ByteBuffer.wrap(data));&#10;        }&#10;    }&#10;&#10;    public void assembleFile(Path partPath, Path finalPath, int chunkSize, long fileSize, byte[] bitset) throws IOException {&#10;        long headerSize = 4 + 4 + 4 + 8 + bitset.length;&#10;        try (var src = FileChannel.open(partPath, java.nio.file.StandardOpenOption.READ);&#10;             var dst = FileChannel.open(finalPath, java.nio.file.StandardOpenOption.CREATE, java.nio.file.StandardOpenOption.WRITE, java.nio.file.StandardOpenOption.TRUNCATE_EXISTING)) {&#10;            src.transferTo(headerSize, fileSize, dst);&#10;        }&#10;    }&#10;&#10;    // Add more file/session logic as needed&#10;}&#10;" />
              <option name="updatedContent" value="package vn.com.fecredit.chunkedupload;&#10;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.util.StringUtils;&#10;import org.springframework.web.multipart.MultipartFile;&#10;&#10;import java.io.IOException;&#10;import java.nio.channels.FileChannel;&#10;import java.nio.file.*;&#10;import java.util.Map;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.locks.ReentrantLock;&#10;&#10;/**&#10; * Service for managing chunked file uploads, including file operations, header management,&#10; * and filename tracking. Handles creation and validation of upload files, chunk writing,&#10; * and final file assembly. All operations are file-based and thread-safe.&#10; */&#10;@Service&#10;public class ChunkedUploadService {&#10;    private final Path inProgressDir = Paths.get(&quot;uploads/in-progress&quot;);&#10;    private final Path completeDir = Paths.get(&quot;uploads/complete&quot;);&#10;    private final ConcurrentHashMap&lt;String, String&gt; uploadFilenames = new ConcurrentHashMap&lt;&gt;();&#10;    private final ConcurrentHashMap&lt;String, ReentrantLock&gt; locks = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    public ChunkedUploadService() throws IOException {&#10;        Files.createDirectories(inProgressDir);&#10;        Files.createDirectories(completeDir);&#10;    }&#10;&#10;    public void storeFilename(String uploadId, String filename) {&#10;        uploadFilenames.put(uploadId, filename);&#10;    }&#10;&#10;    public String getFilename(String uploadId) {&#10;        return uploadFilenames.get(uploadId);&#10;    }&#10;&#10;    public void removeFilename(String uploadId) {&#10;        uploadFilenames.remove(uploadId);&#10;    }&#10;&#10;    public Path getPartPath(String uploadId) {&#10;        return inProgressDir.resolve(uploadId + &quot;.part&quot;);&#10;    }&#10;&#10;    public Path getFinalPath(String uploadId) {&#10;        String filename = getFilename(uploadId);&#10;        return completeDir.resolve(uploadId + (StringUtils.hasText(filename) ? (&quot;_&quot; + filename) : &quot;&quot;));&#10;    }&#10;&#10;    public ReentrantLock getLock(String uploadId) {&#10;        return locks.computeIfAbsent(uploadId, k -&gt; new ReentrantLock());&#10;    }&#10;&#10;    public void removeLock(String uploadId) {&#10;        locks.remove(uploadId);&#10;    }&#10;&#10;    public void createOrValidateHeader(Path partPath, int totalChunks, int chunkSize, long fileSize) throws IOException {&#10;        int bitsetBytes = (totalChunks + 7) / 8;&#10;        int headerSize = 4 + 4 + 4 + 8 + bitsetBytes;&#10;        try (var raf = new java.io.RandomAccessFile(partPath.toFile(), &quot;rw&quot;);&#10;             var ch = raf.getChannel()) {&#10;            if (ch.size() == 0) {&#10;                var header = java.nio.ByteBuffer.allocate(headerSize).order(java.nio.ByteOrder.BIG_ENDIAN);&#10;                header.putInt(0xCAFECAFE);&#10;                header.putInt(totalChunks);&#10;                header.putInt(chunkSize);&#10;                header.putLong(fileSize);&#10;                header.put(new byte[bitsetBytes]);&#10;                header.flip();&#10;                ch.write(header, 0);&#10;                raf.setLength(headerSize + (long) totalChunks * chunkSize);&#10;            } else {&#10;                var h = readHeader(ch);&#10;                if (h.totalChunks != totalChunks || h.chunkSize != chunkSize || h.fileSize != fileSize) {&#10;                    throw new IllegalStateException(&quot;Existing upload file has different parameters&quot;);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    public Header readHeader(FileChannel ch) throws IOException {&#10;        var fixed = java.nio.ByteBuffer.allocate(20).order(java.nio.ByteOrder.BIG_ENDIAN);&#10;        ch.read(fixed, 0);&#10;        fixed.flip();&#10;        int magic = fixed.getInt();&#10;        if (magic != 0xCAFECAFE) throw new IOException(&quot;Bad magic in upload file header&quot;);&#10;        int totalChunks = fixed.getInt();&#10;        int chunkSize = fixed.getInt();&#10;        long fileSize = fixed.getLong();&#10;        int bitsetBytes = (totalChunks + 7) / 8;&#10;        var bits = java.nio.ByteBuffer.allocate(bitsetBytes);&#10;        ch.read(bits, 20);&#10;        return new Header(totalChunks, chunkSize, fileSize, bits.array());&#10;    }&#10;&#10;    public static class Header {&#10;        public int totalChunks;&#10;        public int chunkSize;&#10;        public long fileSize;&#10;        public byte[] bitset;&#10;        public Header(int t, int c, long f, byte[] b) {&#10;            this.totalChunks = t;&#10;            this.chunkSize = c;&#10;            this.fileSize = f;&#10;            this.bitset = b;&#10;        }&#10;    }&#10;&#10;    public void writeChunk(Path partPath, int chunkNumber, int chunkSize, byte[] data) throws IOException {&#10;        int idx = chunkNumber - 1;&#10;        try (var raf = new java.io.RandomAccessFile(partPath.toFile(), &quot;rw&quot;);&#10;             var ch = raf.getChannel()) {&#10;            var h = readHeader(ch);&#10;            long headerSize = 4 + 4 + 4 + 8 + h.bitset.length;&#10;            long offset = headerSize + (long) idx * chunkSize;&#10;            ch.position(offset);&#10;            ch.write(java.nio.ByteBuffer.wrap(data));&#10;        }&#10;    }&#10;&#10;    public void assembleFile(Path partPath, Path finalPath, int chunkSize, long fileSize, byte[] bitset) throws IOException {&#10;        long headerSize = 4 + 4 + 4 + 8 + bitset.length;&#10;        try (var src = FileChannel.open(partPath, java.nio.file.StandardOpenOption.READ);&#10;             var dst = FileChannel.open(finalPath, java.nio.file.StandardOpenOption.CREATE, java.nio.file.StandardOpenOption.WRITE, java.nio.file.StandardOpenOption.TRUNCATE_EXISTING)) {&#10;            src.transferTo(headerSize, fileSize, dst);&#10;        }&#10;    }&#10;&#10;    // Add more file/session logic as needed&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/InitResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/InitResponse.java" />
              <option name="updatedContent" value="package vn.com.fecredit.chunkedupload;&#10;&#10;/**&#10; * Response for upload initialization, containing uploadId and file parameters.&#10; */&#10;public class InitResponse {&#10;    public String uploadId;&#10;    public int totalChunks;&#10;    public int chunkSize;&#10;    public long fileSize;&#10;    public String filename;&#10;    public InitResponse(String uploadId, int totalChunks, int chunkSize, long fileSize, String filename) {&#10;        this.uploadId = uploadId;&#10;        this.totalChunks = totalChunks;&#10;        this.chunkSize = chunkSize;&#10;        this.fileSize = fileSize;&#10;        this.filename = filename;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/NextResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/NextResponse.java" />
              <option name="updatedContent" value="package vn.com.fecredit.chunkedupload;&#10;&#10;/**&#10; * Response for the next chunk to be uploaded in the chunked upload flow.&#10; */&#10;public class NextResponse {&#10;    public Integer nextChunk;&#10;    public NextResponse(Integer next) {&#10;        this.nextChunk = next;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/SessionManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/vn/com/fecredit/chunkedupload/SessionManager.java" />
              <option name="updatedContent" value="package vn.com.fecredit.chunkedupload;&#10;&#10;import org.springframework.stereotype.Component;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;@Component&#10;public class SessionManager {&#10;    private final ConcurrentHashMap&lt;String, Long&gt; sessions = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    public void startSession(String uploadId, long fileSize) {&#10;        sessions.put(uploadId, fileSize);&#10;    }&#10;&#10;    public void endSession(String uploadId) {&#10;        sessions.remove(uploadId);&#10;    }&#10;&#10;    public SessionStatus getStatus(String uploadId) {&#10;        Long fileSize = sessions.get(uploadId);&#10;        return new SessionStatus(uploadId, fileSize != null ? fileSize : 0);&#10;    }&#10;&#10;    public static class SessionStatus {&#10;        public String uploadId;&#10;        public long fileSize;&#10;        public SessionStatus(String uploadId, long fileSize) {&#10;            this.uploadId = uploadId;&#10;            this.fileSize = fileSize;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/vn/com/fecredit/chunkedupload/ChunkedUploadControllerTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/vn/com/fecredit/chunkedupload/ChunkedUploadControllerTest.java" />
              <option name="originalContent" value="package vn.com.fecredit.chunkedupload;&#10;&#10;import org.junit.jupiter.api.Test;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;&#10;import org.springframework.boot.test.context.SpringBootTest;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.mock.web.MockMultipartFile;&#10;import org.springframework.test.web.servlet.MockMvc;&#10;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;&#10;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;&#10;&#10;@SpringBootTest&#10;@AutoConfigureMockMvc&#10;public class ChunkedUploadControllerTest {&#10;&#10;    @Autowired&#10;    private MockMvc mockMvc;&#10;&#10;    @Test&#10;    public void testInitAndUploadFlow() throws Exception {&#10;        String initJson = &quot;{\&quot;totalChunks\&quot;:2, \&quot;chunkSize\&quot;:10, \&quot;fileSize\&quot;:20}&quot;;&#10;        String res = mockMvc.perform(post(&quot;/api/upload/init&quot;)&#10;                .contentType(MediaType.APPLICATION_JSON)&#10;                .content(initJson))&#10;                .andExpect(status().isOk())&#10;                .andReturn().getResponse().getContentAsString();&#10;&#10;        // extract uploadId&#10;        String uploadId = res.replaceAll(&quot;.*\\\&quot;uploadId\\\&quot;:\\s*\\\&quot;([^\\\&quot;]+)\\\&quot;.*&quot;, &quot;$1&quot;); // quick extract&#10;&#10;        MockMultipartFile chunk0 = new MockMultipartFile(&quot;file&quot;, &quot;chunk0&quot;, &quot;application/octet-stream&quot;, &quot;0123456789&quot;.getBytes());&#10;        // compute SHA-256 base64&#10;        java.security.MessageDigest md = java.security.MessageDigest.getInstance(&quot;SHA-256&quot;);&#10;        String chunk0Hash = java.util.Base64.getEncoder().encodeToString(md.digest(&quot;0123456789&quot;.getBytes()));&#10;&#10;        mockMvc.perform(multipart(&quot;/api/upload/chunk&quot;)&#10;                .file(chunk0)&#10;                .param(&quot;uploadId&quot;, uploadId)&#10;                .param(&quot;chunkNumber&quot;, &quot;1&quot;)&#10;                .param(&quot;totalChunks&quot;, &quot;2&quot;)&#10;                .param(&quot;chunkSize&quot;, &quot;10&quot;)&#10;                .param(&quot;fileSize&quot;, &quot;20&quot;)&#10;                .param(&quot;chunkChecksum&quot;, chunk0Hash))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.nextChunk&quot;).isNotEmpty());&#10;&#10;        MockMultipartFile chunk1 = new MockMultipartFile(&quot;file&quot;, &quot;chunk1&quot;, &quot;application/octet-stream&quot;, &quot;abcdefghij&quot;.getBytes());&#10;        String chunk1Hash = java.util.Base64.getEncoder().encodeToString(md.digest(&quot;abcdefghij&quot;.getBytes()));&#10;&#10;        mockMvc.perform(multipart(&quot;/api/upload/chunk&quot;)&#10;                .file(chunk1)&#10;                .param(&quot;uploadId&quot;, uploadId)&#10;                .param(&quot;chunkNumber&quot;, &quot;2&quot;)&#10;                .param(&quot;totalChunks&quot;, &quot;2&quot;)&#10;                .param(&quot;chunkSize&quot;, &quot;10&quot;)&#10;                .param(&quot;fileSize&quot;, &quot;20&quot;)&#10;                .param(&quot;chunkChecksum&quot;, chunk1Hash))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.status&quot;).value(&quot;completed&quot;));&#10;&#10;        // Clean up files after test&#10;        java.nio.file.Files.deleteIfExists(java.nio.file.Paths.get(&quot;uploads/in-progress/&quot; + uploadId + &quot;.part&quot;));&#10;        java.nio.file.Files.list(java.nio.file.Paths.get(&quot;uploads/complete&quot;)).forEach(path -&gt; {&#10;            if (path.getFileName().toString().startsWith(uploadId + &quot;_&quot;)) {&#10;                try { java.nio.file.Files.deleteIfExists(path); } catch (Exception ignored) {}&#10;            }&#10;        });&#10;    }&#10;}" />
              <option name="updatedContent" value="package vn.com.fecredit.chunkedupload;&#10;&#10;import org.junit.jupiter.api.Test;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;&#10;import org.springframework.boot.test.context.SpringBootTest;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.mock.web.MockMultipartFile;&#10;import org.springframework.test.web.servlet.MockMvc;&#10;&#10;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;&#10;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;&#10;&#10;@SpringBootTest&#10;@AutoConfigureMockMvc&#10;public class ChunkedUploadControllerTest {&#10;&#10;    @Autowired&#10;    private MockMvc mockMvc;&#10;&#10;    @Test&#10;    public void testInitAndUploadFlow() throws Exception {&#10;        String initJson = &quot;{\&quot;totalChunks\&quot;:2, \&quot;chunkSize\&quot;:10, \&quot;fileSize\&quot;:20, \&quot;filename\&quot;:\&quot;testfile.txt\&quot;}&quot;;&#10;        String res = mockMvc.perform(post(&quot;/api/upload/init&quot;)&#10;                .contentType(MediaType.APPLICATION_JSON)&#10;                .content(initJson))&#10;                .andExpect(status().isOk())&#10;                .andReturn().getResponse().getContentAsString();&#10;&#10;        // extract uploadId&#10;        String uploadId = res.replaceAll(&quot;.*\\\&quot;uploadId\\\&quot;:\\s*\\\&quot;([^\\\&quot;]+)\\\&quot;.*&quot;, &quot;$1&quot;); // quick extract&#10;&#10;        MockMultipartFile chunk0 = new MockMultipartFile(&quot;file&quot;, &quot;chunk0&quot;, &quot;application/octet-stream&quot;, &quot;0123456789&quot;.getBytes());&#10;        // compute SHA-256 base64&#10;        java.security.MessageDigest md = java.security.MessageDigest.getInstance(&quot;SHA-256&quot;);&#10;        String chunk0Hash = java.util.Base64.getEncoder().encodeToString(md.digest(&quot;0123456789&quot;.getBytes()));&#10;&#10;        mockMvc.perform(multipart(&quot;/api/upload/chunk&quot;)&#10;                .file(chunk0)&#10;                .param(&quot;uploadId&quot;, uploadId)&#10;                .param(&quot;chunkNumber&quot;, &quot;1&quot;)&#10;                .param(&quot;totalChunks&quot;, &quot;2&quot;)&#10;                .param(&quot;chunkSize&quot;, &quot;10&quot;)&#10;                .param(&quot;fileSize&quot;, &quot;20&quot;)&#10;                .param(&quot;chunkChecksum&quot;, chunk0Hash))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.nextChunk&quot;).isNotEmpty());&#10;&#10;        MockMultipartFile chunk1 = new MockMultipartFile(&quot;file&quot;, &quot;chunk1&quot;, &quot;application/octet-stream&quot;, &quot;abcdefghij&quot;.getBytes());&#10;        String chunk1Hash = java.util.Base64.getEncoder().encodeToString(md.digest(&quot;abcdefghij&quot;.getBytes()));&#10;&#10;        mockMvc.perform(multipart(&quot;/api/upload/chunk&quot;)&#10;                .file(chunk1)&#10;                .param(&quot;uploadId&quot;, uploadId)&#10;                .param(&quot;chunkNumber&quot;, &quot;2&quot;)&#10;                .param(&quot;totalChunks&quot;, &quot;2&quot;)&#10;                .param(&quot;chunkSize&quot;, &quot;10&quot;)&#10;                .param(&quot;fileSize&quot;, &quot;20&quot;)&#10;                .param(&quot;chunkChecksum&quot;, chunk1Hash))&#10;                .andExpect(status().isOk())&#10;                .andExpect(jsonPath(&quot;$.status&quot;).value(&quot;completed&quot;));&#10;&#10;        // Clean up files after test&#10;        java.nio.file.Files.deleteIfExists(java.nio.file.Paths.get(&quot;uploads/in-progress/&quot; + uploadId + &quot;.part&quot;));&#10;        java.nio.file.Files.list(java.nio.file.Paths.get(&quot;uploads/complete&quot;)).forEach(path -&gt; {&#10;            if (path.getFileName().toString().startsWith(uploadId + &quot;_&quot;)) {&#10;                try { java.nio.file.Files.deleteIfExists(path); } catch (Exception ignored) {}&#10;            }&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>